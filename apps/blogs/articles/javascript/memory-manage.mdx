---
title: JavaScript 内存管理
description: ""
tags: ["JavaScript"]
poster: ""
date: 2024/02/01
---

文章转载于 [web 全栈体系](https://senior-frontend.pages.dev/jsadvanced/function.html)

## JS 内存机制

### 内存空间：栈内存（stack）、堆内存（heap）

1. 栈内存：所有原始数据类型都存储在栈内存中，如果删除一个栈原始数据，遵循先进后出；如下图：a 最先进栈，最后出栈。

![](/images/mdxs/javascript/memory-1.png)

2. 堆内存：引用数据类型会在堆内存中开辟一个空间，并且会有一个十六进制的内存地址，在栈内存中声明的变量的值就是十六进制的内存地址。

![](/images/mdxs/javascript/memory-2.png)

函数也是引用数据类型，我们定一个函数的时候，会在堆内存中开辟空间，会以字符串的形式存储到堆内存中去，如下图：

![](/images/mdxs/javascript/memory-3.png)

```JS
function fn() {
  var i = 10;
  var j = 10;
  console.log(i + j);
}
// 我们直接打印fn会出现一段字符串
console.log(fn);
// 打印结果
/*
  f fn() {
     var i=10;
     var j=10;
     console.log(i+j)
 }
*/

// 加上括号才执行里面的代码
fn(); // 20
```

## 垃圾回收

### 概念：（我们平时创建所有的数据类型都需要内存）

所谓的垃圾回收就是找出那些不再继续使用的变量，然后释放出其所占用的内存，垃圾回收会按照固定的时间间隔周期性的执行这一操作。

### javaScript 使用的垃圾回收机制来自动管理内存，垃圾回收是把双刃剑；垃圾回收是不可见的

- 优势：可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄漏问题。

- 不足：程序员无法掌控内存，javascript 没有暴露任何关于内存的 api，无法强迫进行垃圾回收，无法干预内存管理。

### 垃圾回收的方式

1. 引用计数（reference counting）

跟踪记录每个值被引用的次数，如果一个值引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放

原理：每次引用加 1，被释放减 1，当这个值的引用次数变成 0 时，就将其内存空间释放。

```JS
let obj = { a: 10 } // 引用+1
let obj1 = { a: 10 } // 引用+1
obj = {} //引用减1
obj1 = null //引用为0
```

引用计数的 bug：循环引用

```JS
// ie8较早的浏览器,现在浏览器不会出现这个问题
function Fn() {
  var objA = { a: 10 }
  var objB = { b: 10 }
  objA.c = objB
  objB.c = objA
}
```

2. 标记清除（现代浏览采用标记清除的方式）

#### 概念

标记清除指的是当变量进入环境时，这个变量标记为“进入环境”;而当变量离开环境时，则将其标记为“离开环境”，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间（所谓的环境就是执行环境）

#### 全局执行环境

- 最外围的执行环境
- 根据宿主环境的不同表示的执行环境的对象也不一样，在浏览器中全局执行环境被认为是 window 对象
- 全局变量和函数都是作为 window 对象的属性和方法创建的
- 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境只有当关闭网页的时候才会被销毁）

#### 环境栈（局部）

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，ECMAScript 程序中的执行流正是由这个方便的机制控制着

```JS
function foo (){
    var a = 10   // 被标记进入执行环境
    var b = ‘hello’ // 被标记进入执行环境
}
foo()  //执行完毕，a 和 b 被标记离开执行环境，内存被回收
```

## V8 内存管理机制

### V8 引擎限制内存的原因

- V8 最初为浏览器设计，不太可能遇到大量内存的使用场景（表层原因）
- 防止因为垃圾回收所导致的线程暂停执行的时间过长（深层原因，按照官方的说法以 1.5G 的垃圾回收为例，v8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量的垃圾回收需要 1 秒以上，这里的时间是指 javascript 线程暂停执行的时间，这是不可接受的， v8 直接限制了内存的大小，如果说在 node.js 中操作大内存的对象，可以通过去修改设置去完成，或者是避开这种限制，1.7g 是在 v8 引擎方面做的限制，我们可以使用 buffer 对象，而 buffer 对象的内存分配是在 c++层面进行的，c++的内存不受 v8 的限制）

### V8 回收策略

- v8 采用可一种分代回收的策略，将内存分为两个生代；新生代和老生代
- v8 分别对新生代和老生代使用不同的回收算法来提升垃圾回收效率

### 新生代垃圾回收

from 和 to 组成一个 Semispace（半空间）当我们分配对象时，先在 from 对象中进行分配，当垃圾回收运行时先检查 from 中的对象，当 obj2 需要回收时将其留在 from 空间，而 ob1 分配到 to 空间，然后进行反转，将 from 空间和 to 空间进行互换，进行垃圾 回收时，将 to 空间的内存进行释放，简而言之 from 空间存放不被释放的对象，to 空间存放被释放的对象，当垃圾回收时将 to 空间的对象全部进行回收

![](/images/mdxs/javascript/memory-4.jpg)

### 新生代对象的晋升（新生代中用来存放，生命较短的对象，老生代存放生命较长的对象）

- 在新生代垃圾回收的过程中，当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采取新的算法进行管理

- 在 From 空间和 To 空间进行反转的过程中，如果 To 空间中的使用量已经超过了 25%，那么就将 From 中的对象直接晋升到老生代内存空间中

### 老生代垃圾回收（有 2 种回收方法）

老生代内存空间是一个连续的结构

![](/images/mdxs/javascript/memory-5.jpg)

标记清除（Mark Sweep） Mark Sweep 是将需要被回收的对象进行标记，在垃圾回收运行时直接释放相应的地址空间,红色的区域就是需要被回收的

![](/images/mdxs/javascript/memory-6.jpg)

标记合并（Mark Compact） Mark Compact 将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收

![](/images/mdxs/javascript/memory-7.jpg)
